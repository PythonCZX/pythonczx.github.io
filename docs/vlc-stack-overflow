<!DOCTYPE html><html lang="en" data-theme="classic"><head><title>Stack Buffer Overflow in VLC v0.9.4</title><link rel="shortcut icon" href="/assets/img/favicon.ico"><link rel="alternate" type="application/rss+xml" title="All Content Feed" href="https://shellsharks.com/feeds/all-feed.xml"><link rel="alternate" type="application/rss+xml" title="Post Feed" href="https://shellsharks.com/feeds/feed.xml"><link rel="alternate" type="application/rss+xml" title="Scrolls Feed" href="https://shellsharks.com/feeds/scroll-feed.xml"><link rel="alternate" type="application/rss+xml" title="Infosec Feed" href="https://shellsharks.com/feeds/infosec-feed.xml"><link rel="alternate" type="application/rss+xml" title="Notes Feed" href="https://shellsharks.com/feeds/note-feed.xml"><link rel="alternate" type="application/rss+xml" title="Devlogs Feed" href="https://shellsharks.com/feeds/devlog-feed.xml"><link rel="alternate" type="application/rss+xml" title="Links Feed" href="https://shellsharks.com/feeds/link-feed.xml"><link rel="alternate" type="application/rss+xml" title="Captains Log Feed" href="https://shellsharks.com/feeds/log-feed.xml"><link rel="alternate" type="application/rss+xml" title="Social Web Feed" href="https://shellsharks.com/feeds/socialweb-feed.xml"><link rel="alternate" type="application/rss+xml" title="Life Feed" href="https://shellsharks.com/feeds/life-feed.xml"><link rel="blogroll" type="text/xml" href="https://shellsharks.com/assets/rsrc/shellsharks-blogroll.opml"><link type="text/plain" rel="author" href="https://shellsharks.com/humans.txt" /><link rel="canonical" href="https://shellsharks.com/vlc-stack-overflow"><link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png"><link rel="indieweb" href="/indieweb.txt" /><link href="https://github.com/shellsharks" rel="me"> <!--IndieAuth Provider--><link rel="authorization_endpoint" href="https://indieauth.com/auth"> <!--IndieAuth--><link rel="token_endpoint" href="https://tokens.indieauth.com/token"> <!--IndieAuth token endpoint--> <!--needed for button css--><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous"><link href='/assets/css/style.css' rel='stylesheet' type='text/css'><link href="/assets/css/syntax.css" rel="stylesheet" ><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/regular/style.css" /><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/fill/style.css" /><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/bold/style.css" /><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Michael Sass" /><meta name="description" content="A walkthrough of exploiting a stack-based buffer overflow in VLC." /><meta name="keywords" content="Stack Buffer Overflow in VLC v0.9.4, shellsharks, dev, cve, infosec, red, reverseengineering, ida, exploitdev, technical" /><meta content="shellsharks" property="og:site_name" /><meta name="fediverse:creator" content="@shellsharks@shellsharks.social" /><meta name="robots" content="noai, noimageai, noml" /> <!--https://noml.info--> <script> const currentThemeX = localStorage.getItem('theme') ? localStorage.getItem('theme') : null; if (currentThemeX) { document.documentElement.setAttribute('data-theme', currentThemeX); } else if (matchMedia('(prefers-color-scheme: light)').matches) { localStorage.setItem('theme', "light"); } else if (matchMedia('(prefers-color-scheme: dark)').matches) { localStorage.setItem('theme', "classic"); } else { localStorage.setItem('theme', "classic"); } </script><meta content="Stack Buffer Overflow in VLC v0.9.4" property="og:title"><meta content="article" property="og:type"><meta content="A walkthrough of exploiting a stack-based buffer overflow in VLC." property="og:description"><meta content="https://shellsharks.com/vlc-stack-overflow" property="og:url"><meta content="2019-10-07T12:00:00-04:00" property="article:published_time"><meta content="https://shellsharks.com/about/" property="article:author"><meta content="https://shellsharks-images.s3.amazonaws.com/videotybytes.png" property="og:image"><meta content="infosec" property="article:section"><meta content="dev" property="article:tag"><meta content="cve" property="article:tag"><meta content="infosec" property="article:tag"><meta content="red" property="article:tag"><meta content="reverseengineering" property="article:tag"><meta content="ida" property="article:tag"><meta content="exploitdev" property="article:tag"><meta content="technical" property="article:tag"> <script src="/assets/js/finrand.js"></script><style> @media (max-width: 2048px) { main { width:66%; } } @media (max-width: 1800px) { main { max-width:800px; width:95%; } } @media (max-width: 768px) { main { width:95%; } }</style><body><div class="container"><heading class="container_item"><style> /* * Made by Erik Terwan * 24th of November 2015 * MIT License * * * If you are thinking of using this in * production code, beware of the browser * prefixes. */ #menuToggle { display: block; position: relative; z-index: 1; -webkit-user-select: none; user-select: none; } #menuToggle a { text-decoration: none; transition: color 0.3s ease; color: var(--contrast-font-color); } .menu_section { color: var(--light-font-color); font-weight: 900; } .menu_section:nth-of-type(n+2) { margin-top:20px; } #menuToggle a:hover { color: var(--link-hover-color); } #menuToggle input { display: block; width: 40px; height: 32px; position: absolute; /*top: -7px;*/ /*left: -5px;*/ cursor: pointer; opacity: 0; /* hide this */ z-index: 2; /* and place it over the hamburger */ -webkit-touch-callout: none; } /* * Just a quick hamburger */ #menuToggle span { display: block; width: 27px; height: 3px; margin-bottom: 4px; position: relative; margin-top:4px; background: var(--font-color); border-radius: 3px; z-index: 1; transform-origin: 4px 0px; transition: transform 0.5s cubic-bezier(0.77,0.2,0.05,1.0), background 0.5s cubic-bezier(0.77,0.2,0.05,1.0), opacity 0.55s ease; } #menuToggle span:first-child { transform-origin: 0% 0%; } #menuToggle span:nth-last-child(2) { transform-origin: 0% 100%; } /* * Transform all the slices of hamburger * into a crossmark. */ #menuToggle input:checked ~ span { opacity: 1; transform: rotate(45deg) translate(-2px, -1px); background: var(--link-hover-color); } /* * But let's hide the middle one. */ #menuToggle input:checked ~ span:nth-last-child(3) { opacity: 0; transform: rotate(0deg) scale(0.2, 0.2); } /* * Ohyeah and the last one should go the other direction */ #menuToggle input:checked ~ span:nth-last-child(2) { transform: rotate(-45deg) translate(0, -1px); } /* * Make this absolute positioned * at the top left of the screen */ #menu { position: absolute; left:-10px; width: 200px; /*fit-content;*/ padding: 10px; margin-top:10px; /*display:none;*/ background: var(--light-background-color); color:var(--font-color); list-style-type: none; -webkit-font-smoothing: antialiased; max-height: calc(80vh); overflow:auto; overscroll-behavior: contain; border-radius: 5px; /* to stop flickering of text in safari */ } /* * And let's slide it in from the left */ #menuToggle input:checked ~ ul { display:block; } .hidden { display: none; }</style><div role="navigation" id="hamburger"><div id="menuToggle"> <input type="checkbox" /> <span></span> <span></span> <span></span><ul id="menu" class="hidden"><li class="menu_section">Main<li><a href="/home/feed" ><i class="ph ph-house"></i> Home Feed</a><li><a href="/about" ><i class="ph ph-identification-card"></i> About</a><li><a href="/feeds" ><i class="ph ph-rss"></i> Feeds</a><li><a href="/activity" ><i class="ph ph-pulse"></i> Activity</a><li><a href="https://shellsharks.social/@shellsharks" target="_blank"><i class="ph ph-mastodon-logo"></i> Mastodon</a><li><a href="mailto:mike@shellsharks.com" ><i class="ph ph-envelope"></i> Email</a><li><a href="https://ko-fi.com/shellsharks" ><i class="ph ph-coffee"></i> Buy me a Coffee</a><li id="themetoggler"><i class="ph ph-swatches" id="themetoggle"></i> Toggle theme<li class="menu_section">Site Nav<li><a href="/scrolls" ><i class="ph ph-scroll"></i> Scrolls Newsletter</a><li><a href="/podcast" ><i class="ph ph-microphone"></i> The Shellsharks Podcast</a><li><a href="/notebook" ><i class="ph ph-note"></i> Notebook</a><li><a href="/blogs" ><i class="ph ph-article"></i> Blogs</a><li><a href="/blogs/infosec" ><i class="ph ph-bug"></i> Infosec Blogs</a><li><a href="/captains-log" ><i class="ph-fill ph-notebook"></i> Captain's Log</a><li><a href="/devlog" ><i class="ph ph-code-block"></i> Devlog</a><li><a href="/linklog" ><i class="ph ph-link"></i> Linklog</a><li><a href="/blogroll" ><i class="ph ph-paint-roller"></i> Blogroll</a><li><a href="/fediverse" ><i class="ph ph-fediverse-logo"></i> Fediverse ‚ÅÇ</a><li><a href="/slashes" ><i class="ph ph-folder-simple-star"></i> Slashes</a><li><a href="/uses" ><i class="ph ph-hammer"></i> Uses</a><li><a href="/now" ><i class="ph ph-clock"></i> Now</a><li><a href="/tags" ><i class="ph ph-tag"></i> Tags</a><li><a href="/statboard" ><i class="ph ph-gauge"></i> Statboard</a><li><a href="/changelog" ><i class="ph ph-arrows-left-right"></i> Change Log</a><li><a href="/interests" ><i class="ph ph-heart"></i> Interests</a><li><a href="/ideas" ><i class="ph ph-lightbulb-filament"></i> Ideas</a><li><a href="/bookmarks" ><i class="ph ph-bookmarks"></i> Bookmarks</a><li><a href="/resume" ><i class="ph ph-read-cv-logo"></i> Resume</a><li><a href="/pro" ><i class="ph ph-seal"></i> Shellsharks Pro</a><li><a href="/sharkweek" ><i class="ph ph-calendar-heart"></i> >Shark Week</a><li><a href="/architecture" ><i class="ph ph-blueprint"></i> Architecture</a><li><a href="/roadmap" ><i class="ph ph-road-horizon"></i> Roadmap</a><li><a href="/tags?tag=bestof#info" ><i class="ph ph-star"></i> Best</a><li><a href="/projects" ><i class="ph ph-compass-tool"></i> Projects</a><li><a href="/now#supporting" ><i class="ph ph-hand-heart"></i> Supports</a><li><a href="/uses#referrals" ><i class="ph ph-hand-arrow-up"></i> Referrals</a><li><a href="/style" ><i class="ph ph-frame-corners"></i> Style</a><li><a href="/.well-known/security.txt" ><i class="ph ph-bug"></i> Report a Bug</a><li><a href="/humans.txt" ><i class="ph ph-user-rectangle"></i> Humans</a><li><a href="/disclaimer" ><i class="ph ph-info"></i> License & Disclaimer</a><li><a href="/privacy" ><i class="ph ph-cookie"></i> Privacy</a><li><a href="/starsharks" ><i class="ph ph-sparkle"></i> Starsharks</a><li><a href="/chipotle" ><i class="ph ph-pepper"></i> Chipotle</a><li><a href="/misc" ><i class="ph ph-paperclip"></i> Junk Drawer</a><li><a href="/ocean" ><i class="ph ph-waves"></i> the Ocean</a><li><a href="/void" ><i class="ph ph-spiral"></i> the Void</a><li class="menu_section">Other<li><a href="/public.pgp" ><i class="ph ph-key"></i> PGP Public Key</a><li><a href="https://infosec.pub/c/cybersecurity" target="_blank"><i class="ph ph-hamburger"></i> Infosec.Pub</a><li><a href="https://malici.ous.computer/@shellsharks" target="_blank"><i class="ph ph-linux-logo"></i> malici.ous.computer</a><li><a href="https://mastodon.social/@sass" target="_blank"><i class="ph-fill ph-mastodon-logo"></i> Mastodon.Social</a><li><a href="https://discord.gg/3rkHgtcYbb" target="_blank"><i class="ph ph-discord-logo"></i> Shellsharks Discord</a><li><a href="https://www.linkedin.com/in/mikesass" target="_blank"><i class="ph ph-linkedin-logo"></i> Linkedin</a><li><a href="/toots/infosec-exchange/shellsharks/" ><i class="ph ph-database"></i> Infosec.exchange Toot Archive</a><li><a href="https://github.com/shellsharks" target="_blank"><i class="ph ph-github-logo"></i> Github</a><li><a href="https://fediverse-webring-enthusiasts.glitch.me/profiles/shellsharks_infosec.exchange/index.html" target="_blank"><i class="ph ph-circle"></i> Webring Enthusiasts</a><li><a href="https://fedia.io/m/cybersecurity" target="_blank"><i class="ph ph-square-half"></i> Fedia.io</a><li><img src="/assets/img/avatar.png" height="50" style="position: relative; display: block; margin:auto; margin-top:20px; margin-bottom:20px;" /></ul></div></div><!-- window.onload = function() { var menuButton = document.getElementById('menuToggle'); var menu = document.getElementById('menu'); menu.classList.add('hidden'); document.getElementById("menuToggle").children[0].checked = false; } --> <script> const menuButton = document.getElementById('menuToggle'); const menu = document.getElementById('menu'); var links = menu.querySelectorAll('a'); menuButton.addEventListener('click', () => { if (!menu.contains(event.target)) { menu.classList.toggle('hidden'); } }); document.addEventListener('click', (event) => { if (!menu.contains(event.target) && !menuButton.contains(event.target)) { menu.classList.add('hidden'); if (document.getElementById("menuToggle").children[0].checked) { document.getElementById("menuToggle").children[0].checked = !document.getElementById("menuToggle").children[0].checked; } } }); links.forEach(function(link) { link.addEventListener('click', function(event) { document.querySelector("#hamburger").click(); }); }); </script> <img id="title_image" src="/assets/img/shellsharks.gif" alt="Shellsharks>_" onclick='window.open("/","_self")'> <span style="float:right;"><a href="/search"><i class="ph-bold ph-magnifying-glass" style="color:var(--font-color); font-size:1.6em; top:-2px;"></i></a></span> </heading><nav class="container_item"><ul id="nav_menu" style="list-style-type:none;padding-left: 10px;"><li class="menu_section">Main<li><a href="/home/feed" ><i class="ph ph-house"></i> Home Feed</a><li><a href="/about" ><i class="ph ph-identification-card"></i> About</a><li><a href="/feeds" ><i class="ph ph-rss"></i> Feeds</a><li><a href="/activity" ><i class="ph ph-pulse"></i> Activity</a><li><a href="https://shellsharks.social/@shellsharks" target="_blank"><i class="ph ph-mastodon-logo"></i> Mastodon</a><li><a href="mailto:mike@shellsharks.com" ><i class="ph ph-envelope"></i> Email</a><li><a href="https://ko-fi.com/shellsharks" ><i class="ph ph-coffee"></i> Buy me a Coffee</a><li id="themetoggler"><i class="ph ph-swatches" id="themetoggle"></i> Toggle theme<li class="menu_section">Site Nav<li><a href="/scrolls" ><i class="ph ph-scroll"></i> Scrolls Newsletter</a><li><a href="/podcast" ><i class="ph ph-microphone"></i> The Shellsharks Podcast</a><li><a href="/notebook" ><i class="ph ph-note"></i> Notebook</a><li><a href="/blogs" ><i class="ph ph-article"></i> Blogs</a><li><a href="/blogs/infosec" ><i class="ph ph-bug"></i> Infosec Blogs</a><li><a href="/captains-log" ><i class="ph-fill ph-notebook"></i> Captain's Log</a><li><a href="/devlog" ><i class="ph ph-code-block"></i> Devlog</a><li><a href="/linklog" ><i class="ph ph-link"></i> Linklog</a><li><a href="/blogroll" ><i class="ph ph-paint-roller"></i> Blogroll</a><li><a href="/fediverse" ><i class="ph ph-fediverse-logo"></i> Fediverse ‚ÅÇ</a><li><a href="/slashes" ><i class="ph ph-folder-simple-star"></i> Slashes</a><li><a href="/uses" ><i class="ph ph-hammer"></i> Uses</a><li><a href="/now" ><i class="ph ph-clock"></i> Now</a><li><a href="/tags" ><i class="ph ph-tag"></i> Tags</a><li><a href="/statboard" ><i class="ph ph-gauge"></i> Statboard</a><li><a href="/changelog" ><i class="ph ph-arrows-left-right"></i> Change Log</a><li><a href="/interests" ><i class="ph ph-heart"></i> Interests</a><li><a href="/ideas" ><i class="ph ph-lightbulb-filament"></i> Ideas</a><li><a href="/bookmarks" ><i class="ph ph-bookmarks"></i> Bookmarks</a><li><a href="/resume" ><i class="ph ph-read-cv-logo"></i> Resume</a><li><a href="/pro" ><i class="ph ph-seal"></i> Shellsharks Pro</a><li><a href="/sharkweek" ><i class="ph ph-calendar-heart"></i> >Shark Week</a><li><a href="/architecture" ><i class="ph ph-blueprint"></i> Architecture</a><li><a href="/roadmap" ><i class="ph ph-road-horizon"></i> Roadmap</a><li><a href="/tags?tag=bestof#info" ><i class="ph ph-star"></i> Best</a><li><a href="/projects" ><i class="ph ph-compass-tool"></i> Projects</a><li><a href="/now#supporting" ><i class="ph ph-hand-heart"></i> Supports</a><li><a href="/uses#referrals" ><i class="ph ph-hand-arrow-up"></i> Referrals</a><li><a href="/style" ><i class="ph ph-frame-corners"></i> Style</a><li><a href="/.well-known/security.txt" ><i class="ph ph-bug"></i> Report a Bug</a><li><a href="/humans.txt" ><i class="ph ph-user-rectangle"></i> Humans</a><li><a href="/disclaimer" ><i class="ph ph-info"></i> License & Disclaimer</a><li><a href="/privacy" ><i class="ph ph-cookie"></i> Privacy</a><li><a href="/starsharks" ><i class="ph ph-sparkle"></i> Starsharks</a><li><a href="/chipotle" ><i class="ph ph-pepper"></i> Chipotle</a><li><a href="/misc" ><i class="ph ph-paperclip"></i> Junk Drawer</a><li><a href="/ocean" ><i class="ph ph-waves"></i> the Ocean</a><li><a href="/void" ><i class="ph ph-spiral"></i> the Void</a><li class="menu_section">Other<li><a href="/public.pgp" ><i class="ph ph-key"></i> PGP Public Key</a><li><a href="https://infosec.pub/c/cybersecurity" target="_blank"><i class="ph ph-hamburger"></i> Infosec.Pub</a><li><a href="https://malici.ous.computer/@shellsharks" target="_blank"><i class="ph ph-linux-logo"></i> malici.ous.computer</a><li><a href="https://mastodon.social/@sass" target="_blank"><i class="ph-fill ph-mastodon-logo"></i> Mastodon.Social</a><li><a href="https://discord.gg/3rkHgtcYbb" target="_blank"><i class="ph ph-discord-logo"></i> Shellsharks Discord</a><li><a href="https://www.linkedin.com/in/mikesass" target="_blank"><i class="ph ph-linkedin-logo"></i> Linkedin</a><li><a href="/toots/infosec-exchange/shellsharks/" ><i class="ph ph-database"></i> Infosec.exchange Toot Archive</a><li><a href="https://github.com/shellsharks" target="_blank"><i class="ph ph-github-logo"></i> Github</a><li><a href="https://fediverse-webring-enthusiasts.glitch.me/profiles/shellsharks_infosec.exchange/index.html" target="_blank"><i class="ph ph-circle"></i> Webring Enthusiasts</a><li><a href="https://fedia.io/m/cybersecurity" target="_blank"><i class="ph ph-square-half"></i> Fedia.io</a></ul></nav><main class="container_item"><div class="pageheader"></div><article class="post h-entry"><header class="post-header"><h1 class="post-title p-name" id="title" style="display:inline;">Stack Buffer Overflow in VLC v0.9.4</h1><span style="color:#CA3342;font-size:4em;line-height: 20px;">.</span></header><!--<div id="postinfo"> <span class="time"><i class="ph ph-note-pencil"></i> by <span class="hov p-author h-card">Mike Sass</span> <a href="/about" rel="author"><img class="u-photo" src="https://shellsharks-images.s3.amazonaws.com/surfshark.png" style="display:inline; height:1em;" /></a></span><br/> <br/> <span class="categories"> &raquo; infosec, blog </span></div>--><div class="post-content e-content" style="margin-top: 30px;"><p>The following analysis details a stack buffer-overflow in VLC version &lt;=0.9.4. The source (for those who want to follow along) is available on my Github <a href="https://github.com/shellsharks/assorted/tree/master/storage">here</a>.<p><strong>*</strong> <em>Following this analysis requires some understanding of <a href="/intel-assembly-primer#title">Intel assembly and basic reverse engineering concepts</a>.</em><hr /><div class="containbox"> <b>This walkthrough is inspired by coursework from my Reverse Engineering and Vulnerability Analysis course at Johns Hopkins University. More information and credit for this vulnerability can be found on the NVD page for <a href="https://nvd.nist.gov/vuln/detail/CVE-2008-4654">CVE-2008-4654</a></b></div><center><img src="https://shellsharks-images.s3.amazonaws.com/2019/vlc.mini.svg" alt="vlc" width="125px" /></center><h2 id="analysis-of-source-code">Analysis of Source Code</h2><p>The vulnerable function (<em>parse_master</em>) lies in the <em>ty.c</em> file located in folder <em>vlc/vlc-0.9.4_src/modules/demux/ty.c</em>. The <em>parse_master</em> function is on line 1623 of the <em>ty.c</em> source file. The relevant vulnerable portion of that function is provided below‚Ä¶<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_master</span><span class="p">(</span><span class="n">demux_t</span> <span class="o">*</span><span class="n">p_demux</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">demux_sys_t</span> <span class="o">*</span><span class="n">p_sys</span> <span class="o">=</span> <span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">p_sys</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">mst_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_map_size</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">i_save_pos</span> <span class="o">=</span> <span class="n">stream_Tell</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">int64_t</span> <span class="n">i_pts_secs</span><span class="p">;</span>

    <span class="cm">/* Note that the entries in the SEQ table in the stream may have
       different sizes depending on the bits per entry.  We store them
       all in the same size structure, so we have to parse them out one
       by one.  If we had a dynamic structure, we could simply read the
       entire table directly from the stream into memory in place. */</span>

    <span class="cm">/* clear the SEQ table */</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">seq_table</span><span class="p">);</span>

    <span class="cm">/* parse header info */</span>
    <span class="n">stream_Read</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">mst_buf</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
    <span class="n">i_map_size</span> <span class="o">=</span> <span class="n">U32_AT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mst_buf</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>  <span class="cm">/* size of bitmask, in bytes */</span>
    <span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_bits_per_seq_entry</span> <span class="o">=</span> <span class="n">i_map_size</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">U32_AT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mst_buf</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>   <span class="cm">/* size of SEQ table, in bytes */</span>
    <span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_seq_table_size</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">i_map_size</span><span class="p">);</span>

    <span class="cm">/* parse all the entries */</span>
    <span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">seq_table</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_seq_table_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ty_seq_table_t</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_seq_table_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stream_Read</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">mst_buf</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">i_map_size</span><span class="p">);</span>
        <span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">seq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l_timestamp</span> <span class="o">=</span> <span class="n">U64_AT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mst_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i_map_size</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">msg_Err</span><span class="p">(</span><span class="n">p_demux</span><span class="p">,</span> <span class="s">"Unsupported SEQ bitmap size in master chunk"</span><span class="p">);</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">seq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chunk_bitmask</span><span class="p">,</span> <span class="n">i_map_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">seq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chunk_bitmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mst_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">i_map_size</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p>* The <em>.dll</em> which contains the compiled vulnerable source is in <em>/vlc/vlc-0.9.4/plugins/libty_plugin.dll</em>. Load this into IDA or an equivalent disassembler and you can peek into the assembly code as well.<p>Starting with the source, we see two variables, <em>mst_buf</em>, declared as an array of 32 <em>uint8_t</em> (8-bit/1-byte unsigned) integers and <em>i_map_size</em> which is declared as a signed integer (32-bits).<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">mst_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_map_size</span><span class="p">;</span>
</code></pre></div></div><p>Further in, we see the first of two <em>stream_Read</em> function calls. This first call reads 32 bytes into the initialized <em>mst_buf</em> array. What‚Äôs important to note here, is this <em>stream_Read</em> takes data from a user-supplied source (namely, the chosen video file) and stuffs it into the buffer.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream_Read</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">mst_buf</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</code></pre></div></div><p>Provided, is an example video file, <em><a href="https://github.com/shellsharks/assorted/tree/master/storage">video.ty+</a></em> (which is a short Tivo video file), which can be used as input. The <em>parse_master</em> function is called from the conditional displayed below (also located in same the <em>ty.c</em> file). Essentially, as VLC is processing the user input (video) file, if it encounters the 32-bit <em>TIVO_PES_FILEID</em> magic DWORD (which is <em>0xf5467abd</em>) it will call <em>parse_master</em> with <em>p_demux</em> as the parameter. <em>p_demux</em> is the remaining bytes of the input file <strong>STARTING</strong> with the magic DWORD.<p><strong>Conditional which calls <em>parse_master</em> function when <em>TIVO_PES_FILEID</em> bytes are encountered.</strong><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span> <span class="n">U32_AT</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">p_peek</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="n">TIVO_PES_FILEID</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* parse master chunk */</span>
        <span class="n">parse_master</span><span class="p">(</span><span class="n">p_demux</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">get_chunk_header</span><span class="p">(</span><span class="n">p_demux</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>Definition of <em>TIVO_PES_FILEID</em> DWORD</strong><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TIVO_PES_FILEID   ( 0xf5467abd )
</span></code></pre></div></div><p>Moving down, we see the variable <em>i_map_size</em> initialized as <em>U32_AT(&amp;mst_buf[20])</em> which from the <em>U32_AT</em> inline function shown below will return a 4-byte integer (Endianness is Big-Endian) using the bytes starting at offset 20 of the <em>mst_buf</em> buffer. Given that we know <em>mst_buf</em> contains user-controlled data, we know now that <em>i_map_size</em> can be any arbitrary 4-byte integer.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">U32_AT</span><span class="p">(</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">_p</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
              <span class="o">|</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>In the second <em>stream_Read</em> call (located in the for loop) we see that <em>8 + i_map_size</em> bytes are read from the input buffer (the video file) into <em>mst_buf</em>. This should immediately throw the red flag as we know <em>mst_buf</em> is only 32 8-bit integers wide and <em>i_map_size</em> can be an arbitrarily large number (any signed 32-bit integer which can be as large as 2147483647/<em>7FFFFFFFh</em>) provided by the user.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_seq_table_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stream_Read</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">mst_buf</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">i_map_size</span><span class="p">);</span>
</code></pre></div></div><p>Using the provided <a href="https://github.com/shellsharks/assorted/tree/master/storage">video.ty+</a> file we can search (using a hex editor) for the magic bytes described earlier (<em>f5 46 7a bd</em>). One occurrence of this byte sequence is found at offset <em>0x00300000</em> in the video file. Moving to offset 20 (<em>0x300014h</em> in the file) from the start of the magic bytes we see a value of ‚Äú<em>00 00 00 02</em>‚Äù. This means (based on this particular video input file sample) that <em>i_map_size</em> will be set to a value of 2.<p>Now that we see where we can affect the <em>i_map_size</em> variable and that the second <em>stream_Read</em> function can be used to overflow the <em>mst_buf</em>, let‚Äôs move to the disassembled code to get a better understanding of how many bytes are needed in order to overwrite the return address and take control of the instruction pointer.<h2 id="analysis-of-disassembly">Analysis of Disassembly</h2><p>Once you‚Äôve loaded <em>libty_plugin.dll</em> into IDA, you can search the available strings for the string ‚Äú<em>Unsupported SEQ bitmap size in master chunk</em>‚Äù which we know resides in the <em>parse_master</em> function.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">msg_Err</span><span class="p">(</span><span class="n">p_demux</span><span class="p">,</span> <span class="s">"Unsupported SEQ bitmap size in master chunk"</span><span class="p">);</span>
</code></pre></div></div><p>This string is referenced somewhere in the middle (offset <em>0x61401CF8</em>) of the <em>parse_master</em> function in the disassembled code.<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.rdata:</span><span class="err">61409158</span> <span class="nf">aUnsupportedSeq</span> <span class="nv">db</span> <span class="err">'</span><span class="nv">Unsupported</span> <span class="nv">SEQ</span> <span class="nv">bitmap</span> <span class="nb">si</span><span class="nv">ze</span> <span class="nv">in</span> <span class="nv">master</span> <span class="nb">ch</span><span class="nv">unk</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>
<span class="nl">.rdata:</span><span class="err">61409158</span>                                         <span class="c1">; DATA XREF: sub_61401AE0+218‚Üëo</span>
</code></pre></div></div><p>Once in the <em>parse_master</em> function we can identify the first <em>stream_Read</em> call (at offset <em>0x61401C1F</em>) and analyze the arguments being set up for the function call (shown below). Of note, is the <em>lea</em> instruction which dereferences memory at <em>[esp+0FCh+var_3C]</em> into <em>edx</em> (which is then passed into <em>stream_Read</em> as the pointer to the <em>mst_buf</em> array buffer). When converted, <em>0FCh+var_3C</em> is equal to <em>C0h</em>. With this information, we know that the <em>mst_buf</em> array exists on the stack at <em>esp+C0h</em> and goes to <em>esp+E0h</em> (since we know the array is 32/<em>20h</em> bytes wide).<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">...</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C05</span>                 <span class="nv">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mh">20h</span> <span class="c1">;move 32 into ecx</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C0A</span>                 <span class="nv">lea</span>     <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0FCh</span><span class="o">+</span><span class="nv">var_3C</span><span class="p">]</span> <span class="c1">; pointer to mst_buf array at ESP+C0</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C11</span>                 <span class="nv">mov</span>     <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0FCh</span><span class="o">+</span><span class="nv">var_F4</span><span class="p">],</span> <span class="nb">ecx</span> <span class="c1">; 3rd param into stream_Read</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C15</span>                 <span class="nv">mov</span>     <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0FCh</span><span class="o">+</span><span class="nv">var_F8</span><span class="p">],</span> <span class="nb">edx</span> <span class="c1">; 2nd param into stream_Read</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C19</span>                 <span class="nv">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="o">+</span><span class="mh">3Ch</span><span class="p">]</span> <span class="c1">;pointer to p_demux input</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C1C</span>                 <span class="nv">mov</span>     <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0FCh</span><span class="o">+</span><span class="nv">Memory</span><span class="p">],</span> <span class="nb">edi</span> <span class="c1">;input stream 1st param into stream_Read</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">C1F</span>                 <span class="nv">call</span>    <span class="nv">stream_Read</span>
<span class="nf">...</span>
</code></pre></div></div><p>Moving to the top of the function (at offset <em>0x61401AE0</em>), we can examine the prologue (displayed below‚Ä¶)<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE0</span>                 <span class="nv">push</span>    <span class="nb">ebp</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE1</span>                 <span class="nv">xor</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE3</span>                 <span class="nv">push</span>    <span class="nb">edi</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE4</span>                 <span class="nv">xor</span>     <span class="nb">ebp</span><span class="p">,</span> <span class="nb">ebp</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE6</span>                 <span class="nv">push</span>    <span class="nb">esi</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE7</span>                 <span class="nv">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AE9</span>                 <span class="nv">push</span>    <span class="nb">ebx</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AEA</span>                 <span class="nv">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AEC</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">0ECh</span>
<span class="nl">.text:</span><span class="err">61401</span><span class="nf">AEC</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">0ECh</span>
</code></pre></div></div><p>As with any prologue, registers are being saved and room for local variables is being made on the stack. There are 4 pushes (registers being saved) and a <em>sub</em> instruction of <em>ECh</em> (room for local variables). Since we know <em>mst_buf</em> begins at <em>esp+C0h</em> and is 32 bytes in size we know that the end of this stack variable is at <em>esp+E0h</em>. Since <em>ECh</em> bytes were allocated for this function, we know that another 12 (<em>Ch</em>) bytes of stack space exist between the end of <em>mst_buf</em> and where <em>EBX</em> was pushed onto the stack. If you account for the 32 bytes of space taken by <em>mst_buf</em> on the stack, plus the 12 bytes of extra local variable space, plus the 4 saved registers (each 4 bytes wide) as well as the return address (4 bytes) which was put on the stack when <em>parse_master</em> was called, there are 64 total bytes that must be overwritten to overwrite the return address.<p>A (crude) representation of the relevant stack items is shown below‚Ä¶<p><strong>Stack Representation</strong><table><thead><tr><th>Bytes<th>Data<tbody><tr><td>‚Ä¶<td>‚Ä¶lower memory addresses‚Ä¶<tr><td>32 Bytes<td>esp+C0h through esp+E0h which we know is mst_buf<tr><td>12 Bytes<td>esp+E0h through esp+ECh which we know is the remaining local variable stack space<tr><td>4 Bytes<td>push ebx moves DWORD value of EBX onto stack<tr><td>4 Bytes<td>push esi moves DWORD value of ESI onto stack<tr><td>4 Bytes<td>push edi moves DWORD value of EDI onto stack<tr><td>4 Bytes<td>push ebp moves DWORD value of EBP onto stack<tr><td>4 Bytes<td>Return Address saved onto stack when parse_master function is called<tr><td>‚Ä¶<td>‚Ä¶higher memory addresses‚Ä¶</table><p><br /> From this representation you can see that we need to write 64 (<em>40h</em>) bytes into <em>mst_buf</em> to overwrite the return address. Since we know from the source code that the second <em>stream_Read</em> reads in <em>8 + i_map_size</em> bytes into <em>mst_buf</em> we know that we need to set <em>i_map_size</em> to 64 - 8 which is <em>38h</em>.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream_Read</span><span class="p">(</span><span class="n">p_demux</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">mst_buf</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">i_map_size</span><span class="p">);</span>
</code></pre></div></div><p>Returning to our <em>video.ty+</em> file - we can overwrite the byte offset we know corresponds to <em>i_map_size</em> with the byte values <em>00 00 00 38</em>. Now, since the second <em>stream_Read</em> call occurs in a <em>for</em> loop, we want to ensure that it is only called once (so that additional data isn‚Äôt read into <em>mst_buf</em>). The <em>for</em> loop will execute <em>i_seq_table_size</em> amount of times and <em>i_seq_table_size</em> is set as <em>i / (8 + i_map_size)</em> which we can see from the source file.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p_sys</span><span class="o">-&gt;</span><span class="n">i_seq_table_size</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">i_map_size</span><span class="p">);</span>
</code></pre></div></div><p>Since we have set <em>i_map_size</em> to 56(<em>38h</em>) we need to set <em>i</em> to a value which will result in <em>i_seq_table_size</em> being 1 (remember we want the <em>for</em> loop to only execute once). We can see from the source that <em>i</em> is set to the value <em>U32_AT(&amp;mst_buf[28])</em>.<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="n">U32_AT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mst_buf</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>
</code></pre></div></div><p>So, moving 8 bytes further into the <em>.ty+</em> file we can set the value that will ultimately be passed into <em>i</em>. From here, if we set <em>mst_buf[28]</em> equal to <em>40h</em> (byte values <em>00 00 00 40</em>) and <em>mst_buf[20]</em> byte values to 38h (<em>00 00 00 38</em>), we can have the <em>for</em> loop execute only once! Since <em>64 / (8 + 56)</em> = 1.<p>Moving on, if we move to the <em>64h</em>/4 (16th) DWORD starting at offset <em>0x00300020</em> of the <em>video.ty</em> file (remember, the first <em>stream_Read</em> call read in 32 bytes starting at the magic DWORD so we must start the second <em>stream_Read</em> at this offset) we see the byte values <em>00 00 03 20</em>. We now know from all our previous analysis that if we overwrite this value (and play this file in VLC), it will overwrite the return function on the stack and when the return instruction is called at the end of the <em>parse_master</em> function, it will return execution to that address which we now control! A graphic of the relevant bytes is provided below‚Ä¶<p><img src="https://shellsharks-images.s3.amazonaws.com/videotybytes.png" alt="Video.ty+ Bytes" /><h2 id="code-execution">Code Execution</h2><p>With control over execution, we can do the usual steps for arbitrary code execution. Namely, generate shellcode, add it to the input file so that it is written onto the stack immediately after we overwrite the original return return address (as part of the <em>mst_buf</em> overflow), then use a memory address pointing to a JMP ESP instruction residing in <em>libty_plugin.dll</em> (or elsewhere we can find a JMP ESP in memory) as our new return address which will result in our shellcode being jumped to once the <em>parse_master</em> function returns.<hr /><p>Feel free to <a href="/contact">message me</a> if something here wasn‚Äôt clear (I admit I am prone to writing confusingly long sentences) and thanks for reading!</div></article><hr class="fin"><div id="poststats" class="containbox" style="margin: auto;"> <span class="time"><i class="ph ph-calendar-dot"></i> Published: <span class="dt-published">October 7, 2019</span></span> <a class="u-url u-uid" href></a><br> <span class="categories"><i class="ph ph-tag"></i> Tags: <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=dev">#dev</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=cve">#cve</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=infosec">#infosec</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=red">#red</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=reverseengineering">#reverseengineering</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=ida">#ida</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=exploitdev">#exploitdev</a></span> <span class="primarybg" style="border-radius:15px;padding:0px 5px 0px 5px;"><a class="p-category" href="/tags?tag=technical">#technical</a></span> </span><br/> <span class="time"><i class="ph ph-pencil"></i> Word count: 2525</span> <span class="p-summary" style="display:none;">A walkthrough of exploiting a stack-based buffer overflow in VLC.</span></div><br/><div class="PageNavigation"> <a class="prev" style="margin-right: 2em;" href="/intel-assembly-primer#title">&laquo; A Primer on Intel Assembly</a><div style="float:right;"><a class="next" href="/vlc-heap-overflow#title" style="margin-right:0;">Heap Buffer Overflow in VLC v0.9.4 &raquo;</a></div></div></main><aside class="container_item"></aside><footer class="container_item"> <center><span style="color:var(--light-font-color); font-size:.8em; font-style:italic; position:relative; top:25px;">Brought to you with <i class="ph-fill ph-heart-straight" style="color:var(--accent-color);"></i> by <a href="https://shellsharks.com/about">Shellsharks</a></span></center> <center> <img id="sharkfooter" src="/assets/img/sharks-circling.png" alt="Circling Sharks" style="width:150px;"></img> </center></footer></div><noscript><div class="panel" align="center" style="font-weight:bold;"><h1>Please enable JavaScript.</h1></div></noscript> <script src="/assets/js/themeswitcher.js"></script>
